"use strict";

exports.__esModule = true;
exports.Pane = Pane;

var _core = require("@react-leaflet/core");

var _react = _interopRequireWildcard(require("react"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const DEFAULT_PANES = ['mapPane', 'markerPane', 'overlayPane', 'popupPane', 'shadowPane', 'tilePane', 'tooltipPane'];
const PANE_STYLES = {
  position: 'absolute',
  top: 0,
  right: 0,
  bottom: 0,
  left: 0
};

function omitPane(obj, pane) {
  const {
    [pane]: _p,
    ...others
  } = obj;
  return others;
}

function Pane(props) {
  const context = (0, _core.useLeafletContext)();
  const paneElementRef = (0, _react.useRef)(null);
  const propsRef = (0, _react.useRef)(props);

  function applyStyles(paneElement) {
    if (props.className != null) {
      (0, _core.addClassName)(paneElement, props.className);
    }

    if (props.style != null) {
      Object.keys(props.style).forEach(key => {
        // @ts-ignore
        paneElement.style[key] = props.style[key];
      });
    }
  }

  function createPane() {
    const name = props.name;

    if (DEFAULT_PANES.indexOf(name) !== -1) {
      throw new Error(`You must use a unique name for a pane that is not a default Leaflet pane: ${name}`);
    }

    if (context.map.getPane(name) != null) {
      throw new Error(`A pane with this name already exists: ${name}`);
    }

    const parentPane = context.pane ? context.map.getPane(context.pane) : undefined;
    paneElementRef.current = context.map.createPane(name, parentPane);
    applyStyles(paneElementRef.current);
  }

  function removePane(name) {
    const pane = context.map.getPane(name);
    pane == null ? void 0 : pane.remove == null ? void 0 : pane.remove(); // @ts-ignore map internals

    if (context.map._panes != null) {
      // @ts-ignore map internals
      context.map._panes = omitPane(context.map._panes, name); // @ts-ignore map internals

      context.map._paneRenderers = omitPane( // @ts-ignore map internals
      context.map._paneRenderers, name);
    }
  }

  (0, _react.useEffect)(function handlePane() {
    if (paneElementRef.current === null) {
      createPane();
    } else if (props !== propsRef.current) {
      if (props.name === propsRef.current.name) {
        // Remove the previous css class name from the pane if it has changed.
        // setStyle() will take care of adding in the updated className
        if (propsRef.current.className && props.className !== propsRef.current.className) {
          (0, _core.removeClassName)(paneElementRef.current, propsRef.current.className);
        } // Update the pane's DOM node style and class


        applyStyles(paneElementRef.current);
      } else {
        removePane(propsRef.current.name);
        createPane();
      }
    }

    return function removeCreatedPane() {
      removePane(props.name);
    };
  });
  const newContext = (0, _react.useMemo)(() => ({ ...context,
    pane: props.name
  }), [context, props.name]);
  return props.children ? /*#__PURE__*/_react.default.createElement(_core.LeafletProvider, {
    value: newContext
  }, /*#__PURE__*/_react.default.createElement("div", {
    style: PANE_STYLES
  }, props.children)) : null;
}